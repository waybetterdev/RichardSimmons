# Description:
#   Get a list of the issues assigned to your on a repo
#
# Dependencies:
#   node-geocoder
#
#
# Configuration:
#   HUBOT_TIMEZONEDB_API_KEY
#
# Commands:
#   hubot where is <username>
#   hubot <username> is in <location>
#   hubot time me [username]
#
# Author:
#   parkr
_ = require('underscore')

geocoder = require('node-geocoder').getGeocoder('google', 'http', {})
timezonedbKey = process.env["HUBOT_TIMEZONEDB_API_KEY"]

unless timezonedbKey?
  console.log "Whoops, can't use /time me, as HUBOT_TIMEZONEDB_API_KEY isn't set."

monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
]

dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
]

now = ->
  Math.round(new Date().getTime() / 1000)

userId = (robot, userName) ->
  userName

locationForUser = (robot, userName) ->
  robot.brain.data.locations[userId(robot, userName)]

setLatitudeAndLongitudeOnUser = (robot, user, lat, lon) ->
  id = userId(robot, user)
  robot.brain.data.locations[id]       ?= {}
  robot.brain.data.locations[id]["lat"] = lat
  robot.brain.data.locations[id]["lon"] = lon

setLocationForUser = (robot, user, location, cb) ->
  robot.brain.data.locations[userId(robot, user)] ?= {}
  robot.brain.data.locations[userId(robot, user)]["stringLocation"] = location
  geocodeNewLocation robot, user, location, cb

geocodeNewLocation = (robot, user, location, cb) ->
  geocoder.geocode location, (err, res) ->
    if err
      console.log err
      cb("There was an error: #{err}")
    else
      setLatitudeAndLongitudeOnUser(robot, user, res[0].latitude, res[0].longitude)
      cb("Ok, updated #{user}'s location to '#{location}'")

relativeToNoon = (hours) ->
  if hours - 12 > 0
    "PM"
  else
    "AM"

formattedUnixTime = (timestamp) ->
  date = new Date(parseInt(timestamp) * 1000)
  console.log date
  "#{dayNames[date.getUTCDay()]}, #{monthNames[date.getUTCMonth()]} #{date.getUTCDate()} at #{date.getUTCHours()}:#{date.getUTCMinutes()} #{relativeToNoon(date.getUTCHours())}."

timeAtLatitudeAndLongitude = (robot, location, cb) ->
  robot.http("http://api.timezonedb.com/").query
    key: timezonedbKey,
    lat: location.lat,
    lng: location.lon,
    time: now(),
    format: "json"
  .get() (err, res, body) ->
    if err or JSON.parse(body).status != "OK"
      cb "An error occurred fetching the time :("
    else
      info = JSON.parse body
      cb "It's currently #{formattedUnixTime info.timestamp} in #{location.stringLocation}."

module.exports = (robot) ->
  robot.brain.data.locations ?= {}

  robot.respond /time me ([\w\-]+)/i, (msg) ->
    user = msg.match[1]
    if user? and robot.brain.data.locations[userId(robot, user)]?
      location = robot.brain.data.locations[userId(robot, user)]
      timeAtLatitudeAndLongitude robot, location, (message) ->
        msg.send message
    else
      msg.send "Sorry, I don't know where #{user} is so I can't tell what time zone he or she is in. :("

  robot.respond /([\w\-]+) will be (.*)/i, (msg) ->
    user = msg.match[1]
    location = msg.match[2]
    setLocationForUser robot, user, location (message) ->
      msg.send message

  robot.respond /where is ([\w\-]+)/i, (msg) ->
    user     = msg.match[1]
    location = locationForUser(robot, user)
    if location?
      msg.send "#{user} is #{location.stringLocation}."
      msg.send "From #{new Date()}"
    else
      msg.send "Sorry, no idea where #{user} is."
      memoriesByRecollection = () -> robot.brain.data.memoriesByRecollection ?= {}
  memories = () -> robot.brain.data.remember ?= {}

  findSimilarMemories = (key) ->
    searchRegex = new RegExp(key, 'i')
    Object.keys(memories()).filter (key) -> searchRegex.test(key)

  robot.respond /(?:what is|rem(?:ember)?)\s+(.*)/i, (msg) ->
    words = msg.match[1]
    if match = words.match /(.*?)(\s+is\s+([\s\S]*))$/i
      msg.finish()
      key = match[1].toLowerCase()
      value = match[3]
      currently = memories()[key]
      if currently
        msg.send "But #{key} is already #{currently}.  Forget #{key} first."
      else
        memories()[key] = value
        msg.send "OK, I'll remember #{key}."
    else if match = words.match /([^?]+)\??/i
      msg.finish()

      key = match[1].toLowerCase()
      value = memories()[key]

      if value
        memoriesByRecollection()[key] ?= 0
        memoriesByRecollection()[key]++
      else
        if match = words.match /\|\s*(grep\s+)?(.*)$/i
          searchPattern = match[2]
          matchingKeys = findSimilarMemories(searchPattern)
          if matchingKeys.length > 0
            value = "I remember:\n#{matchingKeys.join('\n')}"
          else
            value = "I don't remember anything matching `#{searchPattern}`"
        else
          matchingKeys = findSimilarMemories(key)
          if matchingKeys.length > 0
            keys = matchingKeys.join('\n')
            value = "I don't remember `#{key}`. Did you mean:\n#{keys}"
          else
            value = "I don't remember anything matching `#{key}`"

      msg.send value

  robot.respond /forget\s+(.*)/i, (msg) ->
    key = msg.match[1].toLowerCase()
    value = memories()[key]
    delete memories()[key]
    delete memoriesByRecollection()[key]
    msg.send "I've forgotten #{key} is #{value}."

  robot.respond /what do you remember/i, (msg) ->
    msg.finish()
    keys = []
    keys.push key for key of memories()
    msg.send "I remember:\n#{keys.join('\n')}"

  robot.respond /what are your favorite memories/i, (msg) ->
    msg.finish()
    sortedMemories = _.sortBy Object.keys(memoriesByRecollection()), (key) ->
      memoriesByRecollection()[key]
    sortedMemories.reverse()

    msg.send "My favorite memories are:\n#{sortedMemories[0..20].join('\n')}"

  robot.respond /(me|random memory|memories)$/i, (msg) ->
    msg.finish()
    randomKey = msg.random(Object.keys(memories()))
    msg.send randomKey
    msg.send memories()[randomKey]

  robot.respond /mem(ory)? bomb x?(\d+)/i, (msg) ->
    keys = []
    keys.push value for key,value of memories()
    unless msg.match[2]
      count = 10
    else
      count = parseInt(msg.match[2])

    msg.send(msg.random(keys)) for [1..count]

